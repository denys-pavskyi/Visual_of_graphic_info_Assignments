
// // Vertex shader
// const vertexShaderSource = `
// attribute vec3 vertex;
// attribute vec3 normal;
// varying vec3 normalInterp;
// varying vec3 fragPos;
// varying vec3 lightDir;
// uniform mat4 ModelViewProjectionMatrix;
// uniform mat4 NormalMatrix;
// uniform vec3 lightPos;

// void main() {
//     gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);
//     fragPos = vec3(ModelViewProjectionMatrix * vec4(vertex, 1.0));
//     normalInterp = normalize(vec3(NormalMatrix * vec4(normal, 0.0)));
//     lightDir = normalize(lightPos - fragPos);
// }
// `;

// // Fragment shader
// const fragmentShaderSource = `
// #ifdef GL_FRAGMENT_PRECISION_HIGH
//    precision highp float;
// #else
//    precision mediump float;
// #endif

// varying vec3 normalInterp;
// varying vec3 fragPos;
// varying vec3 lightDir;

// void main() {
//     vec3 ambientColor = vec3(0.1, 0.1, 0.05);
//     vec3 diffuseColor = vec3(1.0, 1.0, 0.5);
//     vec3 specularColor = vec3(0.0, 0.0, 0.0);

//     vec3 normal = normalize(normalInterp);
//     vec3 lightDirNorm = normalize(lightDir);
//     vec3 viewDir = normalize(-fragPos);

//     float lambertian = max(dot(normal, lightDirNorm), 0.0);
//     float specular = 0.0;

//     if (lambertian > 0.0) {
//         vec3 reflectDir = reflect(-lightDirNorm, normal);
//         float specAngle = max(dot(reflectDir, viewDir), 0.0);
//         specular = pow(specAngle, 30.0); 
//     }

//     vec3 lighting = ambientColor + (lambertian * diffuseColor) + (specular * specularColor);
//     gl_FragColor = vec4(lighting, 1.0);

// }
// `;


// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec2 a_texcoord;

uniform mat4 ModelViewProjectionMatrix;

varying vec2 v_texCoord;

void main() {
    gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);
    v_texCoord = a_texcoord;
}`;


// Fragment shader
const fragmentShaderSource = `
precision mediump float;

varying vec2 v_texCoord;
uniform sampler2D u_texture;
uniform float u_textureRotation;

void main() {
    // Rotate texture coordinates around the center
    vec2 rotatedTexCoord = vec2(
        (v_texCoord.x - 0.5) * cos(u_textureRotation) - (v_texCoord.y - 0.5) * sin(u_textureRotation) + 0.5,
        (v_texCoord.x - 0.5) * sin(u_textureRotation) + (v_texCoord.y - 0.5) * cos(u_textureRotation) + 0.5
    );

    // float tmo_rot = 0.5;
    // vec2 rotatedTexCoord = vec2(
    //     (v_texCoord.x - 0.5) * cos(tmo_rot) - (v_texCoord.y - 0.5) * sin(tmo_rot) + 0.5,
    //     (v_texCoord.x - 0.5) * sin(tmo_rot) + (v_texCoord.y - 0.5) * cos(tmo_rot) + 0.5
    // );

    // Fetch texel from the texture
    vec4 texColor = texture2D(u_texture, rotatedTexCoord);
    //vec4 texColor = texture2D(u_texture, v_texCoord);

    // Output the color from the texture
    gl_FragColor = texColor;

    //float res = 1.0/v_texCoord[1];

    //gl_FragColor = vec4(0.5,0.5,0,1);
    // gl_FragColor = vec4(u_textureRotation/100.0,0.5,0,1);
    // if(u_textureRotation==0.0){
    //     //gl_FragColor = vec4(u_textureRotation/10.0,0.5,0,1);
    // }
    // if(u_textureRotation==100.0){
    //     gl_FragColor = vec4(0.0,0,1,1);
    // }
}`;





/////////////////////
/// SPHERE SHADER ///
/////////////////////

// Vertex shader
const SphereVertexShaderSource = `
attribute vec3 vertex;
uniform mat4 ModelViewProjectionMatrix;

void main() {
    gl_Position = ModelViewProjectionMatrix * vec4(vertex,1.0);
}`;


// Fragment shader
const SphereFragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

uniform vec4 color;
void main() {
    gl_FragColor = color;
}`;